# -*- coding: utf-8 -*-
"""Convex-Lab_Desafio_Unisoma_2020

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1INg07Psp6JCkSPzRwN6k1Znl1PJ6zToy

# Instalacao de bibliotecas
"""

#!pip install pandas
#!pip install numpy
#!pip install scipy
#!pip install PuLP #Tem que instalar essa!

"""# Banco de dados - SQL"""

def get_parametro_from_table(df_parametro,chave):
  return int(df_parametro.valor[df_parametro.chave==chave])

def create_dataframe(table,conn):
  return pd.read_sql_query("SELECT * FROM "+table+";",conn)

def leitura_BD(file_BD, table_names, param_list):
  if os.path.isfile(file_BD):
    conn = sqlite3.connect(file_BD)
    
    dfs_dict = {}
    for tab in table_names:    
        dfs_dict[tab] = create_dataframe(tab,conn)    

    conn.close()

    param_dict = {}
    for par in param_list:   
      param_dict[par] = get_parametro_from_table(dfs_dict['parametro'],par)
  else:
    print("FILE NOT FOUND")
    
  return dfs_dict, param_dict

def salva_BD(file_BD, df_sol_turma, df_sol_aluno, df_sol_formulario):
  print("Salva BD em ", file_BD) 
  if os.path.isfile(file_BD):
    conn_sol = sqlite3.connect(file_BD)
  
    #Nao salva coluna ignore_index
    df_sol_turma[['id','nome', 'qtd_max_alunos', 'qtd_professores_acd', 'qtd_professores_pedagogico', 'escola_id', 'serie_id', 'aprova']].to_sql('sol_turma', con = conn_sol, if_exists = 'replace', chunksize = 1000)  
    df_sol_formulario.to_sql('sol_priorizacao_formulario', con = conn_sol, if_exists = 'replace', chunksize = 1000)
    df_sol_aluno.to_sql('sol_aluno', con = conn_sol, if_exists = 'replace', chunksize = 1000)

    conn_sol.close()
  else:
    print("FILE NOT FOUND")

"""# Pre-processamento - Tabelas

##Serie
"""

def calc_proxima_serie(df_aluno_param, df_serie, row, i, max_serie_ordem,incr=1): #default incrementa uma serie
  #print("incr",incr) #debug
  #print(row) #debug
  aluno_serie_valida=0
  if row['ordem'] < max_serie_ordem :    
    next_ordem = (int(row['ordem'])+incr)    
    
    if next_ordem <= max_serie_ordem:
      next_serie = int(df_serie['id'][df_serie['ordem']==next_ordem])
      #Verificar se a serie que o aluno quer cursar esta ativas. Alunos que cursariam series inativas sao desconsiderados no planejamento
      #print("next serie:", next_serie) #debug
      #print("serie:", df_serie['ativa'][ df_serie['id']==next_serie ]) #debug
      if int(df_serie['ativa'][ df_serie['id']==next_serie ])==1 :
          df_aluno_param.loc[int(i),'serie_id_otim'] =next_serie     
          aluno_serie_valida=1 
    
  if aluno_serie_valida == 0:  
    #print(".........2 drop row", i) #debug
    #print(row) #debug
    df_aluno_param=df_aluno_param.drop([i],axis=0)

  return df_aluno_param

def pre_processamento_serie(df_serie):  
  #Determina ultima serie ativa da ONG (ativa)
  max_serie_ordem=max(df_serie['ordem'][df_serie['ativa']==1])
  max_serie_id= int(df_serie.id[df_serie['ordem']==max(df_serie['ordem'])])
  
  return df_serie, max_serie_ordem, max_serie_id

"""## Alunos de continuidade"""

def calc_alunos_continuidade_proxima_serie(df_aluno_serie, df_serie, max_serie_ordem, otimiza_dentro_do_ano):  
  df_aluno_serie['serie_id_otim']=0
  
  if otimiza_dentro_do_ano==0:     #identifica a próxima série dos alunos  
    for i, row in df_aluno_serie.iterrows():
      df_aluno_serie = calc_proxima_serie(df_aluno_serie, df_serie, row, i, max_serie_ordem)           
  else: #caso contrario, usa a serie atual
    df_aluno_serie['serie_id_otim']=df_aluno_serie['serie_id']

  return df_aluno_serie

def pre_processamento_alunos_continuidade(df_aluno, df_turma, df_serie, otimiza_dentro_do_ano, max_serie_ordem):

  #--- Desconsiderar alunos que nao vao continuar na ONG -> TODO: colocar na query sql
  df_aluno = df_aluno[df_aluno['continua']==1]

  #----- Nova tabela df_aluno_serie: informações de escola e série dos alunos

  #Inclui serie_id  
  df_aluno_serie = df_aluno.merge(df_turma[['id','escola_id','serie_id']], how='left', left_on='turma_id', right_on='id',suffixes=('','_y'))   
  df_aluno_serie=df_aluno_serie.drop(columns=['id_y'])  #aqui vale que df_aluno_turma_id == turma.id (id_y)
  #Inclui serie.ordem
  df_aluno_serie = df_aluno_serie.merge(df_serie[['id','ordem']], how='left', left_on='serie_id', right_on='id', suffixes=('','_y'))
  df_aluno_serie=df_aluno_serie.drop(columns=['id_y']) #TODO: TESTAR

  #--- Proxima serie dos alunos de continuidade, tabela: df_aluno_serie    
  df_aluno_serie = calc_alunos_continuidade_proxima_serie(df_aluno_serie, df_serie, max_serie_ordem, otimiza_dentro_do_ano)

  return df_aluno_serie

"""## Alunos de formulario"""

def calc_alunos_formulario_proxima_serie(df_formulario_inscricao_serie, df_serie, max_serie_ordem, ano_planejamento):
  #obs: ultima serie e a 5

  df_formulario_inscricao_serie['serie_id_otim']=0
  #df_formulario_inscricao_serie.head()

  #identifica a proxima serie dos alunos, quando ano<ano_planejamento
  for i, row in df_formulario_inscricao_serie.iterrows():
    #print("iter",i) #debug
    #print("ano_planejamento:",ano_planejamento) #debug
    #print("ano_ref_row:", row['ano_referencia']) #debug
    diferenca_ano_ref = ano_planejamento - row['ano_referencia']
    if diferenca_ano_ref>0:
      #print("diferenca ano-ref",diferenca_ano_ref) #debug
      df_formulario_inscricao_serie = calc_proxima_serie(df_formulario_inscricao_serie, df_serie, row, i, max_serie_ordem,incr=diferenca_ano_ref)       

  return df_formulario_inscricao_serie

def pre_processamento_alunos_formulario(df_formulario_inscricao, df_serie, max_serie_ordem, ano_planejamento):
  #--- Inclui serie e serie.ordem na tabela dos alunos de formulario - Tabela: df_formulario_inscricao_serie: 

  #Tabela df_formulario_inscricao_serie  
  df_formulario_inscricao_serie = df_formulario_inscricao

  #inclui serie.ordem dos alunos de formulario
  df_formulario_inscricao_serie = df_formulario_inscricao_serie.merge(df_serie[['id','ordem']], how='left', left_on='serie_id', right_on='id', suffixes=('','_y'))
  df_formulario_inscricao_serie=df_formulario_inscricao_serie.drop(columns=['id_y'])

  #print("alunos formulario") #debug 
  #print(df_formulario_inscricao_serie.head(20)) #debug

  #--- Serie dos alunos de formulario: se ano de referencia < ano_planejamento, precisa colocar o aluno na proxima serie
  df_formulario_inscricao_serie = calc_alunos_formulario_proxima_serie(df_formulario_inscricao_serie, df_serie, max_serie_ordem, ano_planejamento)

  #--- Ordena alunos por data de inscricao

  df_formulario_inscricao_serie_rank=df_formulario_inscricao_serie

  df_formulario_inscricao_serie_rank['data_inscricao'] = pd.to_datetime(df_formulario_inscricao_serie_rank['data_inscricao'], format='%d/%m/%Y %H:%M:%S')

  df_formulario_inscricao_serie_rank['rank'] = df_formulario_inscricao_serie_rank['data_inscricao'].rank(method='dense', ascending = True).astype(int)
  df_formulario_inscricao_serie_rank.sort_values(by='rank',inplace = True)

  return df_formulario_inscricao_serie

"""# Fase 1 - aloca os alunos de continuidade - permite abertura de novas turmas

Cenarios:
alunos de formulario que vao cursar o 9o 
nenhuma turma pre-existente
alunos reprovados

## Restricoes
"""

#Se alunos i e j estavam na mesma turma, então eles tem que continuar, desde que nenhum deles tenha sido reprovado.
def restricao_alunos_mesma_turma(model, xc, df_aluno, turmas_new_idx_list):  
  for i in df_aluno.index:
    if df_aluno['reprova'][i] == 0: #se o aluno i nao reprovar
      aluno_i_turma = df_aluno['turma_id'][i]
    
      for j in df_aluno.index:
        #se o aluno j nao reprovar e se i e j estavam na mesma turma
        if i!= j and df_aluno['reprova'][j] == 0 and aluno_i_turma == df_aluno['turma_id'][j]:
          #print('alunos ' + str(df_aluno['id'][i]) + ' e ' + str(df_aluno['id'][j])+ ' estavam na mesma turma') #debug
    
          for t in turmas_new_idx_list:
            #duvida: alunos de continuidade podem ser alocados em novas turmas?
            model += xc[(i,t)] == xc[(j,t)] 
  
  return model, xc

#Cada aluno deve ser alocado na serie apropriada, determinada de acordo com as regras:
def restricao_aluno_serie(model, x_par, y, df_aluno_par, df_serie, turmas_new_idx_list):
  
  for i in df_aluno_par.index:
    for t in turmas_new_idx_list: #considera tanto as turmas ja existentes, quanto as novas que podem ser criadas
      s_id= df_aluno_par['serie_id_otim'][i] #serie que o aluno vai cursar
      s_index = df_serie[  df_serie['id'] ==s_id ].index[0]
      #print('aluno_form: ' + str(df_aluno_par['id'][i]) + ',serie=' + str(s_id) + ', index=' + str(s_index))  
      model += x_par[(i,t)] <= y[(t,s_index)]
  return model, x_par, y

#Cada aluno i só pode ser alocado na turma t se a turma se ela existir na escola e que ele escolheu:
def restricao_aluno_escola(model, x_par, y, z, df_aluno_par, df_escola, turmas_new_idx_list):
  for i in df_aluno_par.index:
    for t in turmas_new_idx_list: #considera tanto as turmas ja existentes, quanto as novas que podem ser criadas
      e_id= df_aluno_par['escola_id'][i] #escola que o aluno vai estudar
      e_index = df_escola[ df_escola['id'] ==e_id ].index[0]
      #print('i:'+str(i)+ ', aluno: ' + str(df_aluno_par['id'][i]) + ', escola=' + str(e_id) + ', index=' + str(e_index))  
      model += x_par[(i,t)] <= z[(t,e_index)]

  return model, x_par, y, z

#Turmas pré-existentes já tem a série e a escola definidas.
def restricao_define_turma_existente(model, y, z, v_turma_aberta, df_turma, df_serie, df_escola, turmas_existentes_idx_list):
  for t in turmas_existentes_idx_list:  #turmas existentes    
    #Definir a serie da turma    
    s_id=df_turma['serie_id'][t]  
    s_index = df_serie[  df_serie['id'] ==s_id ].index[0]  
    #print(str(df_turma['nome'][t]) + ', turma=' + str(t)+ ':id=' + str(df_turma['id'][t]) +',serie=' + str(s_id) + ', index=' + str(s_index)) #debug
    model += y[(t,s_index)] == 1
    
    #Definir a escola da turma
    e_id=df_turma['escola_id'][t]  
    e_index = df_escola[  df_escola['id'] ==e_id ].index[0]    
    #print(str(df_turma['nome'][t]) + ', turma=' + str(t)+',escola=' + str(e_id) + ', index=' + str(e_index)) #debug
    model += z[(t,e_index)] == 1

    #Turmas pre existentes sao marcadas como abertas        
    model += v_turma_aberta[t] == 1
  
  return model, y, z, v_turma_aberta

#Custo maximo da ONG
def restricao_limite_custo_ONG(model, xc, xf, v_turma_aberta, df_aluno, df_formulario, turmas_new_idx_list, param_dict):
  custo_turma_professores_t = param_dict['custo_professor']*(param_dict['qtd_professores_pedagogico'] + param_dict['qtd_professores_acd'])
  
  #nao precisa multiplicar custo_turma_alunos_t por v_turma_aberta porque a restricao R8 garante que xc e xf so sao maiores do que 0 quando v_turma_aberta=1
  custo_turma_alunos_t=0
  for t in turmas_new_idx_list:    
    custo_turma_alunos_t += ( lpSum(xc[(i,t)] for i in df_aluno.index) + lpSum( xf[(i,t)] for i in df_formulario.index) )* param_dict['custo_aluno']

  model += custo_turma_alunos_t + lpSum( custo_turma_professores_t* v_turma_aberta[t] for t in turmas_new_idx_list ) <= param_dict['limite_custo']
  
  return model, xc, xf, v_turma_aberta

def restricao_alunos_vagas_turma(model, xc, xf, v_folga, v_vagas_livres, v_turma_aberta, df_aluno, df_formulario, turmas_new_idx_list, param_dict):
  for t in turmas_new_idx_list:    
    #print('turma t=' + str(t))
    #Soma os alunos de continuidade e os de formulario em cada turma aberta, variavel de folga calcula as vagas sobrando em todas as turmas
    model += lpSum( xc[(i,t)] for i in df_aluno.index) + lpSum( xf[(i,t)] for i in df_formulario.index) + v_vagas_livres[t] == v_turma_aberta[t] * param_dict['qtd_max_alunos']    

  return model, xc, xf, v_folga, v_vagas_livres, v_turma_aberta

"""## Variaveis de decisao"""

#------------- Variaveis de decisao
def fase1_declara_vars_decisao(alunos_idx_list, formulario_idx_list, turmas_new_idx_list, serie_idx_list, escola_idx_list, param_dict):
  xc = LpVariable.dicts("aluno_turma",
                                [(i, t) for i in alunos_idx_list #indices dos alunos no dataframe
                                        for t in turmas_new_idx_list], #indice das turmas 
                                0, 1, LpBinary)

  xf = LpVariable.dicts("aluno_formulario",
                                [(i, t) for i in formulario_idx_list #indices dos alunos no dataframe
                                        for t in turmas_new_idx_list], #indice das turmas 
                                0, 1, LpBinary)
  
  v_turma_aberta = LpVariable.dicts("turma_aberta",  turmas_new_idx_list, 0,1, LpBinary ) #maior numero de vagas vazias em uma turma e qtd_max_alunos


  y = LpVariable.dicts("turma_serie",
                                [(t, s) for t in turmas_new_idx_list #indices dos alunos no dataframe
                                        for s in serie_idx_list], #indice das turmas 
                                0, 1, LpBinary)

  z = LpVariable.dicts("turma_escola",
                                [(t, s) for t in turmas_new_idx_list #indices dos alunos no dataframe
                                        for s in escola_idx_list], #indice das turmas 
                                0, 1, LpBinary)  
  v_folga = LpVariable.dicts("v_folga", turmas_new_idx_list, 0, param_dict['qtd_max_alunos'] ) #maior numero de vagas vazias em uma turma e qtd_max_alunos

  v_vagas_livres = LpVariable.dicts("v_vagas_livres", turmas_new_idx_list, 0, param_dict['qtd_max_alunos'] ) #maior numero de vagas vazias em uma turma e qtd_max_alunos

  return xc, xf, v_turma_aberta, y, z, v_folga, v_vagas_livres

"""## Fase 1 - Funcao objetivo"""

#Fase 1: Funcao objetivo
# minimiza as vagas vazias nas turmas
# so sao criadas turmas para acomodar os alunos de continuidade
# assim, nao e necessario maximizar o numero de alunos de formulario acomodados

def fase1_funcao_objetivo(model, v_vagas_livres, v_turma_aberta, xf, turmas_new_idx_list, turmas_existentes_idx_list, df_formulario):
  #Minimiza as vagas de folga das turmas, ou seja, maximiza as vagas utilizadas nas turmas, i.e. 
  vagas_folga_soma = lpSum(v_vagas_livres[t] for t in turmas_new_idx_list)

  #Turmas pre-existentes sao marcadas como abertas por padrao
  #isso significa que sempre sao consideradas as vagas remanescentes dela
  #dessa forma, so serao abertas novas turmas se nao for possivel alocar nas existentes
  
  tot_turmas_abertas = lpSum(v_turma_aberta[t] for t in turmas_new_idx_list)

  #Prioriza ordem de inscricao
  prioriza_ordem_inscr=0
  for i in df_formulario.index:
    prioriza_ordem_inscr += lpSum( xf[(i,t)]*df_formulario['rank'][i] for t in turmas_new_idx_list)  #minimizar o rank

  #Para ser minimizada:
  fo = + vagas_folga_soma + tot_turmas_abertas + 0.1*prioriza_ordem_inscr
  
  model+=fo
  return model

"""## Extra"""

# Cálculo de u (número máximo de turmas)
def calculo_limitante_superior_u(df_turma):  
  # Como alunos de continuidade tem que se manter na mesma turma que seus colegas, o pior caso aqui e precisar abrir novas turmas com series novas
  u = len(df_turma.index) * 2
  return int(u)

def fase1_define_all_turmas_list(df_turma, param_dict):  
  ub_turmas = calculo_limitante_superior_u(df_turma)
  #print("Limitante superior para o numero de turmas (1a fase)=",ub_turmas) #debug

  max_turma_idx = int(max( df_turma['id'].index))
  max_new_turma_idx = ub_turmas-1

  new_turmas = list(range( max_turma_idx+1, max_new_turma_idx ))
  all_turmas_list = list(df_turma.index) + new_turmas
  
  return all_turmas_list

def modelo_show_solucao(xc, xf, v_turma_aberta, y, z, v_vagas_livres, df_aluno, df_formulario, df_turma, df_serie, df_escola, turmas_new_idx_list):
  count_turmas=0

  #-------------- Resultado
  for t in turmas_new_idx_list:
    print("-------- Turma t="+str(t)) 
    print("Aberta=" + str(v_turma_aberta[t].varValue))
    
    if v_turma_aberta[t].varValue>0:
      count_turmas+=v_turma_aberta[t].varValue     
      if t < len(df_turma['id']):
        print("turma, id=" + str(df_turma['id'][t]))

      for s in df_serie.index:
        if y[(t,s)].varValue >0.1:
          print('serie='+str(s)+", id="+ str(df_serie['id'][s])+ ', y=' + str(  y[(t,s)].varValue))
      for e in df_escola.index:
        if z[(t,e)].varValue >0.1:
          print('escola='+str(e)+", id="+ str(df_escola['id'][e])+ ', y=' + str(  z[(t,e)].varValue))                      
      
      #print("Vagas folga="+ str(v_folga[t].varValue))
      print("Vagas livres="+ str(v_vagas_livres[t].varValue))
      
      for i in df_aluno.index:
        if xc[(i,t)].varValue > 0:
          print('xc['+ str(i)+':id='+str(df_aluno['id'][i]) + ',' + str(t) + ']=' + str(xc[(i,t)].varValue ))
      for i in df_formulario.index:
        if xf[(i,t)].varValue > 0:
          print('xf['+ str(i)+':id='+str(df_formulario['id'][i])  + ',' + str(t) + ']=' + str(xf[(i,t)].varValue ))

  print("turmas abertas = " + str(count_turmas))

#Lista com os alunos de formulario restantes, remove os de xf que ja foram alocados  
#Calcula o orçamento restante  
def apos_fase1_atualiza_dfs_restante(dfs_dict, param_dict, xc, xf, v_vagas_livres, v_turma_aberta, turmas_new_index_list):    
  
  df_formulario_restante = dfs_dict['formulario_inscricao'].copy()
  count_aluno_formulario=0
  for i in df_formulario_restante.index:
    for t in turmas_new_index_list:
      if xf[(i,t)].varValue == 1:
        count_aluno_formulario+=1
        #print("aluno form index=" + str(i)+ ', id=' + str(df_formulario_restante['id'][i]) + ' vai ser apagado') #debug
        df_formulario_restante.drop(i, inplace=True)
  
  count_aluno = 0
  for i in dfs_dict['aluno'].index:
      count_aluno+= sum( xc[(i,t)].varValue for  t in turmas_new_index_list)
      
  count_turma=0
  for t in turmas_new_index_list:
    aberta=sum( xc[(i,t)].varValue for i in dfs_dict['aluno'].index) + sum( xf[(i,t)].varValue for i in dfs_dict['formulario_inscricao'].index)
    if aberta >0:
      count_turma+=1
    
  #Quanto sobra de orcamento? 
  custo_turma_professores_t = param_dict['custo_professor']*(param_dict['qtd_professores_pedagogico'] + param_dict['qtd_professores_acd'])
  custo_turma_alunos_t = ( count_aluno + count_aluno_formulario)* param_dict['custo_aluno']
  orcamento = (count_turma * custo_turma_professores_t + custo_turma_alunos_t)

  orcamento_restante = param_dict['limite_custo'] - orcamento

  orcamento_count_alunos = (orcamento_restante - custo_turma_professores_t)/param_dict['custo_aluno']
  
  #Limitante superior para o numero de alunos na proxima turma:
  num_max_alunos = int(min(orcamento_count_alunos, param_dict['qtd_max_alunos']))

  return df_formulario_restante, orcamento_restante, num_max_alunos

"""## Fase 1 - Modelo"""

def fase1_modelo(dfs_dict, param_dict):
  df_aluno = dfs_dict['aluno']
  df_formulario = dfs_dict['formulario_inscricao']
  df_turma =  dfs_dict['turma']
  df_serie =  dfs_dict['serie']
  df_escola = dfs_dict['escola']

  #------------- Conjunto de indices para turmas 
  turmas_existentes_idx_list = df_turma.index  #turmas ja existentes
  
  if param_dict['possibilita_abertura_novas_turmas']==0:
    turmas_new_idx_list=turmas_existentes_idx_list
  else:  
    turmas_new_idx_list= fase1_define_all_turmas_list(df_turma, param_dict)

  #------------- Inicia o modelo
  model = LpProblem(name="desafio_unisoma_fase1", sense=LpMinimize)

  xc, xf, v_turma_aberta, y, z, v_folga, v_vagas_livres = fase1_declara_vars_decisao(df_aluno.index, df_formulario.index, turmas_new_idx_list, df_serie.index, df_escola.index, param_dict)
  
  #-------------- Funcao objetivo
  model = fase1_funcao_objetivo(model, v_vagas_livres, v_turma_aberta, xf, turmas_new_idx_list, turmas_existentes_idx_list, df_formulario)
  
  #-------------- Restricoes

  #R5
  #Alunos de continuidade (matriculados) tem que obrigatoriamente ser alocados em uma turma:
  for i in df_aluno.index: 
    model+= lpSum( xc[(i,t)] for t in turmas_new_idx_list) == 1
    
  #R1
  #Se alunos i e j estavam na mesma turma e foram aprovados, então eles tem que continuar na mesma turma:
  model, xc = restricao_alunos_mesma_turma(model, xc, df_aluno, turmas_new_idx_list)
  
  #R6
  #Cada aluno de formulario e alocado em no maximo uma turma:
  for i in df_formulario.index:
    model += lpSum( xf[(i,t)] for t in turmas_new_idx_list  ) <= 1

  #R4
  #Turmas pré-existentes já tem a série e a escola definidas:
  model, y, z, v_turma_aberta = restricao_define_turma_existente(model,y,z,v_turma_aberta, df_turma,df_serie,df_escola,turmas_existentes_idx_list)
    
  #R7
  #Cada turma pertence a uma unica serie e escola:
  for t in turmas_new_idx_list:
    model += lpSum( y[(t,s)] for s in df_serie.index) == 1
    model += lpSum( z[(t,e)] for e in df_escola.index) == 1
  
  #R2
  #Cada aluno deve ser alocado na serie apropriada, determinada de acordo com as regras:
  model, xc, y = restricao_aluno_serie(model, xc, y, df_aluno, df_serie, turmas_new_idx_list)    
  model, xf, y = restricao_aluno_serie(model, xf, y, df_formulario, df_serie, turmas_new_idx_list)    

  #R3
  #Cada aluno i só pode ser alocado na turma t se a turma se ela existir na escola que escolheu:
  model, xc, y, z = restricao_aluno_escola(model, xc, y, z, df_aluno, df_escola, turmas_new_idx_list)    
  model, xf, y, z = restricao_aluno_escola(model, xf, y, z, df_formulario, df_escola, turmas_new_idx_list)    

  #Abertura de turmas: Número máximo de alunos por turma e vagas livres
  model, xc, xf, v_folga, v_vagas_livres, v_turma_aberta = restricao_alunos_vagas_turma(model, xc, xf, v_folga, v_vagas_livres, v_turma_aberta, df_aluno, df_formulario, turmas_new_idx_list, param_dict)

  #R9
  #Custo maximo da ONG
  model, xc, xf, v_turma_aberta = restricao_limite_custo_ONG(model, xc, xf, v_turma_aberta, df_aluno, df_formulario, turmas_new_idx_list, param_dict)

  #-------------- Resolve
  print("Chama solver")
  status= model.solve() #COIN(maxSeconds=5) )
  
  #if status > 0:
    #modelo_show_solucao(xc, xf, v_turma_aberta, y, z, v_vagas_livres, df_aluno, df_formulario, df_turma, df_serie, df_escola, turmas_new_idx_list)
    #print("Fase 1 - Solucao encontrada ", status)

  return xc, xf, y, z, v_vagas_livres, v_turma_aberta, turmas_new_idx_list, status

"""## Fase 1 - Salvar"""

def escolhe_nome_nova_turma(dfs_dict, df_sol_turma, nome_turma_serie):
  continua=1
  turma_char='A'
  while chr(ord(turma_char ) ).upper() != 'Z' and continua==1:
    #print(chr(ord(turma_char))) #debug
    nome_turma_tentativa = nome_turma_serie + turma_char
    #print("tentativa: ", nome_turma_tentativa)  #debug
    if nome_turma_tentativa in df_sol_turma['nome'].to_string(index=False).upper():
      continua=1
      #print("continua tentando") #debug
      turma_char = chr(ord(turma_char)+1)
    else:      
      continua=0
  
  if continua==1:
    nome_turma_completo=nome_turma_tentativa + 'b'
  else:
    nome_turma_completo=nome_turma_tentativa

  #print(nome_turma_completo)   #debug
  return nome_turma_completo

##Escrever os alunos de continuidade nas tabelas para o SQL - pegar infos da tabela aluno original
##Escrever os alunos de formulario ja alocados tambem 
##sol_turma - Se alguma turma existente nao for aberta, pode considerar como fechada.
##sol_aluno
##sol_priorizacao_formulario

def fase1_salva_resultados(dfs_dict, param_dict, xc, xf, y,z, v_vagas_livres, v_turma_aberta, turmas_new_idx_list):
  df_sol_aluno = pd.DataFrame(columns=['id','cpf','nome','email','telefone','nome_responsavel', 'telefone_responsavel','nome_escola_origem', 'sol_turma_id'])
  df_sol_formulario = pd.DataFrame(columns=['id','nome','cpf','email_aluno','telefone_aluno','nome_responsavel','telefone_responsavel','escola_id','serie_id','nome_escola_origem','sol_turma_id','status_id'])
  df_sol_turma = pd.DataFrame(columns=['id','nome', 'qtd_max_alunos', 'qtd_professores_acd', 'qtd_professores_pedagogico', 'escola_id', 'serie_id', 'aprova', 'ignore_index'])

  #------------------ Insere turmas no df_sol_turma (sql: sol_turma)
  for t in turmas_new_idx_list:
    aberta=sum( xc[(i,t)].varValue for i in dfs_dict['aluno'].index) + sum( xf[(i,t)].varValue for i in dfs_dict['formulario_inscricao'].index)
    if aberta >0:
      id_insert=0
      nome_insert=""
      
      #recupera a serie na qual a turma foi aberta
      s_idx=0
      for s in dfs_dict['serie'].index:
        if y[(t,s)].varValue >0.1:
          s_idx = s
      #recupera a escola na qual a turma foi aberta
      e_idx=0
      for e in dfs_dict['escola'].index:
        if z[(t,e)].varValue >0.1:
          e_idx = e

      #print("turma index" + str(t) + ", serie_idx="  + str(s_idx) + ", escola_idx" + str(e_idx) ) #debug
      
      #Turma ja existe
      if t in dfs_dict['turma']['id'].index:
        #print("ja existe: turma index" + str(t) + ', id='+ str(dfs_dict['turma']['id'][t]) + ' ja foi formada')   #debug      
        id_insert = dfs_dict['turma']['id'][t]
        nome_insert = dfs_dict['turma']['nome'][t]
        #print("nome_turma" + str(nome_insert))
        aprova_insert = 1
                
      else:  #Nova turma
        #print("(new) nova: turma t ="+str(t))   #debug        
        id_insert = max( df_sol_turma['id']) + 1        
        aprova_insert = 0
        
        regiao_id = dfs_dict['escola']['regiao_id'][e_idx]  
        regiao_nome = dfs_dict['regiao']['nome'][ dfs_dict['regiao']['id'] == regiao_id].to_string(index=False)   
        nome_turma_serie = regiao_nome.replace(' ','') + '_' + dfs_dict['serie']['nome'][s_idx][0]  
        nome_insert = escolhe_nome_nova_turma(dfs_dict,df_sol_turma, nome_turma_serie )

      #ADD TO DATAFRAME TURMA
      df_sol_turma = df_sol_turma.append({'id' : id_insert,
                                          'nome' : nome_insert,   
                                          'qtd_max_alunos' : param_dict['qtd_max_alunos'],
                                          'qtd_professores_acd' :  param_dict['qtd_professores_acd'],
                                          'qtd_professores_pedagogico' :  param_dict['qtd_professores_acd'],
                                          'escola_id' : dfs_dict['escola']['id'][e_idx],
                                          'serie_id' : dfs_dict['serie']['id'][s_idx] ,
                                          'aprova' : aprova_insert,
                                          'ignore_index' : t}
                                         ,  ignore_index = True)  #todo: ignore_index = False? 


            
  #------------------ Insere alunos de formulario no df_sol_formulario (sql: sol_priorizacao_formulario)
  #lista parcial de alunos de formulario: alguns xf ja foram alocados - Essas turmas nao alteram mais

  for i in dfs_dict['formulario_inscricao'].index:
    for t in turmas_new_idx_list:
      if xf[(i,t)].varValue == 1:
        #print("aluno form index=" + str(i)+ ', id=' + str(dfs_dict['formulario_inscricao']['id'][i]) + ' alocado')  #debug
        #print("nome = " + str( dfs_dict['formulario_inscricao']['nome'][i]))  #debug
        #print(df_sol_turma['id'][ df_sol_turma['ignore_index']==t ])  #debug
        #print(int(df_sol_turma['id'][ df_sol_turma['ignore_index']==t ]))  #debug

        #ADD TO DATAFRAME SOL_PRIORIZACAO_FORMULARIO
        df_sol_formulario = df_sol_formulario.append({'id' : dfs_dict['formulario_inscricao']['id'][i],
                                                      'nome' : dfs_dict['formulario_inscricao']['nome'][i],
                                                      'cpf' : dfs_dict['formulario_inscricao']['cpf'][i],
                                                      'email_aluno' : dfs_dict['formulario_inscricao']['email_aluno'][i],
                                                      'telefone_aluno' : dfs_dict['formulario_inscricao']['telefone_aluno'][i],
                                                      'nome_responsavel' : dfs_dict['formulario_inscricao']['nome_responsavel'][i],
                                                      'telefone_responsavel' : dfs_dict['formulario_inscricao']['telefone_responsavel'][i],
                                                      'escola_id' : dfs_dict['formulario_inscricao']['escola_id'][i], 
                                                      'serie_id' : dfs_dict['formulario_inscricao']['serie_id_otim'][i],
                                                      'nome_escola_origem' : dfs_dict['formulario_inscricao']['nome_escola_origem'][i],
                                                      'sol_turma_id' : int(df_sol_turma['id'][ df_sol_turma['ignore_index']==t ]),
                                                      'status_id': ""
                                                      }, 
                ignore_index = True) 
      
  #------------------ Insere alunos de continuidade no df_sol_alunos (sql: sol_alunos)
  #todos os alunos de continuidade estao alocados
  for i in dfs_dict['aluno'].index:
    for t in turmas_new_idx_list:
      if xc[(i,t)].varValue == 1:
        #print("aluno continuidade index=" + str(i)+ ', id=' + str(dfs_dict['aluno']['id'][i]) + ' alocado')        
        #print("nome = " + str( dfs_dict['aluno']['nome'][i]))
        #print(df_sol_turma['id'][ df_sol_turma['ignore_index']==t ])
        #print(int(df_sol_turma['id'][ df_sol_turma['ignore_index']==t ]))

        #ADD TO DATAFRAME SOL_ALUNO
        df_sol_aluno = df_sol_aluno.append({'id' : dfs_dict['aluno']['id'][i],
                                            'cpf' : dfs_dict['aluno']['cpf'][i],
                                            'nome' : dfs_dict['aluno']['nome'][i],
                                            'email': dfs_dict['aluno']['email'][i],
                                            'telefone': dfs_dict['aluno']['telefone'][i],
                                            'nome_responsavel': dfs_dict['aluno']['nome_responsavel'][i],
                                            'telefone_responsavel': dfs_dict['aluno']['telefone_responsavel'][i],
                                            'nome_escola_origem': dfs_dict['aluno']['nome_escola_origem'][i],                                          
                                          'sol_turma_id' : int(df_sol_turma['id'][ df_sol_turma['ignore_index']==t]) },  
                ignore_index = True) 



  #conn_sol = sqlite3.connect("bd_saida_teste_fase1.db") #debug
 
  
  #Nao salva coluna ignore_index
  #df_sol_turma[['id','nome', 'qtd_max_alunos', 'qtd_professores_acd', 'qtd_professores_pedagogico', 'escola_id', 'serie_id', 'aprova']].to_sql('sol_turma', con = conn_sol, if_exists = 'replace', chunksize = 1000)  
  #df_sol_formulario.to_sql('sol_priorizacao_formulario', con = conn_sol, if_exists = 'replace', chunksize = 1000)
  #df_sol_aluno.to_sql('sol_aluno', con = conn_sol, if_exists = 'replace', chunksize = 1000)

  return df_sol_turma, df_sol_aluno, df_sol_formulario

"""# Fase 2"""

#escolhe a proxima serie/escola para abrir, so com alunos de formulario, de acordo com as regras de demanda
def fase2_calc_next_serie_abrir(dfs_dict,param_dict,df_formulario_restante):
  import random
  
  max_dmd1=0
  max_serieid1=0
  max_escolaid1=0
  max_dmd2=0
  max_serieid2=0
  max_escolaid2=0

  serie_id_sel=0
  escola_id_sel=0
  demanda_sel=0

  for eidx in dfs_dict['escola'].index:
    for sidx in dfs_dict['serie'].index:
      #print("serie index=",sidx) #debug
      #print("escola index=",eidx) #debug
      
      demanda= len(df_formulario_restante[ (df_formulario_restante['serie_id_otim']== dfs_dict['serie']['id'][sidx] ) & (df_formulario_restante['escola_id']== dfs_dict['escola']['id'][eidx]) ].index)
      
      #print("demanda",demanda) #debug
      
      if demanda > max_dmd1:   
        max_dmd2=max_dmd1
        max_serieid2=max_serieid1
        max_escolaid2=max_escolaid1
        
        max_dmd1 = demanda
        max_serieid1 = dfs_dict['serie']['id'][sidx]
        max_escolaid1= dfs_dict['escola']['id'][eidx]
      elif demanda > max_dmd2:
        max_dmd2 = demanda
        max_serieid2 = dfs_dict['serie']['id'][sidx]
        max_escolaid2= dfs_dict['escola']['id'][eidx]

  tolerancia = 0.25*param_dict['qtd_max_alunos']
 
  #print("max1..2")  #debug
  #print(max_dmd1)   #debug
  #print(max_dmd2)   #debug
  if max_dmd1 - max_dmd2 > tolerancia or max_dmd2==0:
    #prioriza a maior demanda
    #print("dentro da tolerancia") #debug
    serie_id_sel = max_serieid1
    escola_id_sel = max_escolaid1
    demanda_sel=max_dmd1
  else:
    #deve ser priorizada a série mais nova, ou seja 9o ano tem maior prioridade, seguido do 1o ano, 2o ano e, por fim, 3o ano com a menor prioridade.
    max_ordem1 = int(dfs_dict['serie']['ordem'][ dfs_dict['serie']['id']== max_serieid1])
    max_ordem2 = int(dfs_dict['serie']['ordem'][ dfs_dict['serie']['id']== max_serieid2])

    #print("max...")
    #print(max_serieid1)
    #print(max_ordem2)  
    #print(max_serieid2)
    #print(max_ordem2)
    if max_ordem1 < max_ordem2:
      serie_id_sel = max_serieid1
      escola_id_sel = max_escolaid1
      demanda_sel=max_dmd1
    elif max_ordem2 < max_ordem1:
      serie_id_sel = max_serieid2
      escola_id_sel = max_escolaid2
      demanda_sel=max_dmd2
    else:
      #escolhe aleatoriamente
      serie_id_sel = random.choice([max_serieid1, max_serieid2])
      if serie_id_sel == max_serieid1:
        escola_id_sel = max_escolaid1
        demanda_sel=max_dmd1
      else:
        escola_id_sel = max_escolaid2
        demanda_sel=max_dmd2

  #print("serie_id_sel",serie_id_sel) #debug
  #print("escola_id_sel",escola_id_sel) #debug
  #print("demanda_sel",demanda_sel) #debug

  return serie_id_sel, escola_id_sel

def fase2_novo_orcamento(param_dict, num_alunos_turma, orcamento_restante):
  custo_turma_professores_t = param_dict['custo_professor']*(param_dict['qtd_professores_pedagogico'] + param_dict['qtd_professores_acd'])
  custo_turma_alunos_t = ( num_alunos_turma )* param_dict['custo_aluno']
  orcamento = (custo_turma_professores_t + custo_turma_alunos_t)

  orcamento_restante2 = orcamento_restante- orcamento

  orcamento_count_alunos = (orcamento_restante2 - custo_turma_professores_t)/param_dict['custo_aluno']
  
  #Limitante superior para o numero de alunos na proxima turma:
  num_max_alunos = int(min(orcamento_count_alunos, param_dict['qtd_max_alunos']))

  return orcamento_restante2, num_max_alunos

"""## Fase 2 - Salvar"""

#salvar
def fase2_salva_resultados(dfs_dict, param_dict, df_sol_turma, df_sol_formulario, formulario_selecionados, serie_id_sel, escola_id_sel):
  #cria uma nova turma para esse pessoal        
  turma_id_insert = max( df_sol_turma['id']) + 1        
  aprova_insert = 0

  serie_id_sel 
  escola_id_sel
        
  regiao_id = int( dfs_dict['escola']['regiao_id'][  dfs_dict['escola']['id'] == escola_id_sel  ]   )  
  regiao_nome = dfs_dict['regiao']['nome'][ dfs_dict['regiao']['id'] == regiao_id].to_string(index=False)   
  nome_serie = dfs_dict['serie']['nome'][  dfs_dict['serie']['id']==serie_id_sel  ].to_string(index=False)
  nome_serie = nome_serie.replace(' ','') 
  nome_turma_serie = regiao_nome.replace(' ','') + '_' + nome_serie[0]    
  nome_insert = escolhe_nome_nova_turma(dfs_dict, df_sol_turma, nome_turma_serie )

  #print("reg id", regiao_id) #debug
  #print("reg nome", regiao_nome) #debug
  #print(nome_turma_serie)
  #print("nome_insert")
  #print( nome_insert)

  #ADD TO DATAFRAME TURMA
  df_sol_turma = df_sol_turma.append({'id' : turma_id_insert,
                                      'nome' : nome_insert,   
                                      'qtd_max_alunos' : param_dict['qtd_max_alunos'],
                                      'qtd_professores_acd' :  param_dict['qtd_professores_acd'],
                                      'qtd_professores_pedagogico' :  param_dict['qtd_professores_acd'],
                                      'escola_id' : escola_id_sel,
                                      'serie_id' : serie_id_sel,
                                      'aprova' : 0,
                                      'ignore_index' : -1}
                                      ,  ignore_index = True)  #todo: ignore_index = False? 


  #alunos formulario: 
  for i in formulario_selecionados.index:
    df_sol_formulario = df_sol_formulario.append({'id' : dfs_dict['formulario_inscricao']['id'][i],
                                                    'nome' : dfs_dict['formulario_inscricao']['nome'][i],
                                                    'cpf' : dfs_dict['formulario_inscricao']['cpf'][i],
                                                    'email_aluno' : dfs_dict['formulario_inscricao']['email_aluno'][i],
                                                    'telefone_aluno' : dfs_dict['formulario_inscricao']['telefone_aluno'][i],
                                                    'nome_responsavel' : dfs_dict['formulario_inscricao']['nome_responsavel'][i],
                                                    'telefone_responsavel' : dfs_dict['formulario_inscricao']['telefone_responsavel'][i],
                                                    'escola_id' : dfs_dict['formulario_inscricao']['escola_id'][i], 
                                                    'serie_id' : dfs_dict['formulario_inscricao']['serie_id_otim'][i],
                                                    'nome_escola_origem' : dfs_dict['formulario_inscricao']['nome_escola_origem'][i],
                                                    'sol_turma_id' : turma_id_insert,
                                                    'status_id': ""
                                                    }, 
              ignore_index = True) 

  #conn_sol = sqlite3.connect("bd_saida_teste_fase2.db")

  #Escreve no sql - fase 2
  #df_sol_turma[['id','nome', 'qtd_max_alunos', 'qtd_professores_acd', 'qtd_professores_pedagogico', 'escola_id', 'serie_id', 'aprova']].to_sql('sol_turma', con = conn_sol, if_exists = 'replace', chunksize = 1000)  
  #df_sol_formulario.to_sql('sol_priorizacao_formulario', con = conn_sol, if_exists = 'replace', chunksize = 1000)
  
  return df_sol_turma, df_sol_formulario

"""# MAIN + modelo (fase1 e fase2)"""

import sqlite3
import pandas as pd
import numpy as np
from pulp import *

def main(file_BD="Modelo de Dados - MatMov.db"):
  print("Banco de dados SQL: ", file_BD)
  table_names = {"aluno", "escola", "formulario_inscricao", "regiao", "serie", "status", "turma", "parametro" } 
  param_list = {"ano_planejamento", "otimiza_dentro_do_ano", "possibilita_abertura_novas_turmas", "limite_custo", "custo_aluno", "custo_professor", "qtd_max_alunos", "qtd_professores_pedagogico", "qtd_professores_acd" }

  #Leitura do BD: le tabelas e parametros em dicionarios
  #dfs_dict e um dicionario com dataframes, as chaves sao os nomes das tabelas em table_names
  #param_dict e um dicionario com os parametros, as chaves sao os nomes dos parametros em param_list
  dfs_dict, param_dict = leitura_BD(file_BD, table_names, param_list)

  print("Otimiza dentro do ano:",param_dict['otimiza_dentro_do_ano']) #debug
  
  #Pre-processamento das tabelas
  dfs_dict['serie'], max_serie_ordem, max_serie_id = pre_processamento_serie(dfs_dict['serie'])
  dfs_dict['aluno'] = pre_processamento_alunos_continuidade(dfs_dict['aluno'], dfs_dict['turma'], dfs_dict['serie'], param_dict['otimiza_dentro_do_ano'], max_serie_ordem)
  dfs_dict['formulario_inscricao'] = pre_processamento_alunos_formulario(dfs_dict['formulario_inscricao'], dfs_dict['serie'], max_serie_ordem, param_dict['ano_planejamento'])
  dfs_dict['serie'] = dfs_dict['serie'][dfs_dict['serie']['ativa']==1]

  #---------------- Resolve modelo

  #----------- Fase 1 - modelo de otimizacao
  # Aloca os alunos de continuidade e preenche as vagas remanescentes com alunos de formulario
  # permite abertura de novas turmas, apenas para alocar os de continuidade

  print("Inicia fase 1")
  xc, xf, y, z, v_vagas_livres, v_turma_aberta, turmas_new_idx_list, status = fase1_modelo(dfs_dict, param_dict)

  #Modelo rodou com sucesso:
  if status > 0:
    print("Solver terminou com sucesso")
    # Salva os resultados ate o momento, retorna os dataframes.    
    df_sol_turma, df_sol_aluno, df_sol_formulario = fase1_salva_resultados(dfs_dict, param_dict, xc, xf, y, z, v_vagas_livres, v_turma_aberta, turmas_new_idx_list)   #TODO

    #----------- Fase 2 - novas turmas, procedimento iterativo
    df_formulario_restante, orcamento_restante,num_max_alunos = apos_fase1_atualiza_dfs_restante(dfs_dict, param_dict, xc, xf, v_vagas_livres, v_turma_aberta, turmas_new_idx_list) #ok?    
      
    continua=1
    
    print("Inicia fase 2")
    print("Orcamento restante="+str(orcamento_restante))

    #Enquanto ainda tem orcamento e for possivel alocar pelo menos um aluno (considerando o custo dos professores)
    while orcamento_restante > 0 and num_max_alunos>=1 and continua==1:      
      #Escolhe a serie/escola de maior demanda, de acordo com a nova regra da ONG      
      serie_id_sel, escola_id_sel = fase2_calc_next_serie_abrir(dfs_dict,param_dict,df_formulario_restante)       
      #Preenche com os primeiros num_max_alunos alunos. Como a lista esta rankeada por prioridade, vai sempre selecionar os que tem prioridade
      formulario_selecionados = df_formulario_restante[ (df_formulario_restante['serie_id_otim']==serie_id_sel) & (df_formulario_restante['escola_id']==escola_id_sel) ].head(num_max_alunos) 
      
      if len(df_formulario_restante.index) > 0:
        print("Ainda tem orcamento, abre serie_id="+ str(serie_id_sel) + ", na escola_id" + str(escola_id_sel))
        df_sol_turma, df_sol_formulario = fase2_salva_resultados(dfs_dict, param_dict, df_sol_turma, df_sol_formulario, formulario_selecionados, serie_id_sel, escola_id_sel)        
        #Redefine df_formulario
        df_formulario_restante.drop(formulario_selecionados.index, inplace=True)
        #Calcula orcamento restante e quantos alunos cabem no orcamento (num_max_alunos)    
        orcamento_restante, num_max_alunos = fase2_novo_orcamento(param_dict, len(formulario_selecionados.index), orcamento_restante )       
      else:
        continua=0

    print("Orcamento restante final da ONG="+str(orcamento_restante))
    print("Fim do modelo")       

    #Salva a solucao no banco de dados:    
    salva_BD(file_BD, df_sol_turma, df_sol_aluno, df_sol_formulario)

  else: #Modelo falhou: infactivel    
    print("Solver terminou com modelo infactivel")
    #SE abertura_novas_turmas=0 E INFACTIVEL #ALERTA   
    if param_dict['possibilita_abertura_novas_turmas'] == 0:
      print("ALERTA: nao foi possivel alocar os alunos nas turmas existentes. Considere modificar as turmas existentes ou possibilitar a abertura de novas turmas")
    else:
      print("ALERTA: nao foi possivel alocar os alunos nas turmas existentes.")



"""# Testes"""

print("Teste - arquivo SQL original")
main("Modelo de Dados - MatMov.db") #ou main()
#print("Teste 1")
#main("Modelo de Dados - MatMov - v1.db")
#print("Teste 2")
#main("Modelo de Dados - MatMov - v2.db")
#print("Teste 3")
#main("Modelo de Dados - MatMov - v3.db")
#print("Teste 4")
#main("Modelo de Dados - MatMov - v4.db")
#print("Teste 5")
#main("Modelo de Dados - MatMov - v5.db")
#print("Teste 6")
#main("Modelo de Dados - MatMov - v6.db")